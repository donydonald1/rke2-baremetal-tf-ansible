# harbor:
# we use harbor secret to consolidate all the secrets
existingSecretAdminPassword: harbor
existingSecretAdminPasswordKey: HARBOR_ADMIN_PASSWORD
existingSecretSecretKey: harbor
core:
  replicas: 3
  resources:
    requests:
      cpu: 0.05
      memory: 150Mi
  extraEnvVars:
  - name: OIDC_CLIENT_ID
    valueFrom:
      secretKeyRef:
        name: oidc-harbor
        key: oidc-client-id
  - name: OIDC_CLIENT_SECRET
    valueFrom:
      secretKeyRef:
        name: oidc-harbor
        key: oidc-client-secret
  - name: OIDC_ENDPOINT
    valueFrom:
      secretKeyRef:
        name: oidc-harbor
        key: oidc_issuer-url
  - name: CONFIG_OVERWRITE_JSON
    value: |
      {
        "auth_mode": "oidc_auth",
        "oidc_name": "OIDC",
        "oidc_endpoint": "$(OIDC_ENDPOINT)",
        "oidc_groups_claim": "groups",
        "oidc_admin_group": "superUsers",
        "oidc_client_id": "$(OIDC_CLIENT_ID)",
        "oidc_client_secret": "$(OIDC_CLIENT_SECRET)",
        "oidc_scope": "openid,email,groups,name",
        "oidc_verify_cert": "true",
        "oidc_auto_onboard": "true",
        "oidc_user_claim": "name"
      }

jobservice:
  replicas: 3
  secret: ""
  jobLoggers:
  - database
  resources:
    requests:
      cpu: 0.5
      memory: 300Mi

registry:
  replicas: 3
  secret: ""
  credentials:
    # username is defined in existingSecret below, but this value also used by jobservice, so let's align it
    username: harbor_registry_user
    # we use harbor secret to consolidate all the secrets
    # Secret keys must be REGISTRY_PASSWD and REGISTRY_HTPASSWD. For key REGISTRY_PASSWD the value is the password.
    # For key REGISTRY_HTPASSWD the value is the string in the password file generated by htpasswd where the username
    # is harbor_registry_user and the encryption type is bcrypt.
    # For example: `htpasswd -bBc passwordfile harbor_registry_user harbor_registry_password`. The username must be harbor_registry_user!
    existingSecret: harbor
  registry:
    resources:
      requests:
        cpu: 0.5
        memory: 300Mi
trivy:
  # enabled the flag to enable Trivy scanner
  enabled: true
  gitHubToken: ""
fullnameOverride: harbor
externalURL: https://harbor.prod.techsecom.io
ipFamily:
  # ipv6Enabled set to true if ipv6 is enabled in cluster, currently it affected the nginx related component
  ipv6:
    enabled: false
expose:
  tls:
    # we are behind a load balancer, so we don't need to use TLS
    enabled: true
    certSource: secret
    #   secretName: harbor-tls
    secret:
      # The name of secret which contains keys named:
      # "tls.crt" - the certificate
      # "tls.key" - the private key
      secretName: harbor-tls
    # the certificate is used to serve the Harbor UI, API, and registry
  ingress:
    className: nginx
    annotations:
      gethomepage.dev/enabled: "true"
      gethomepage.dev/group: Home
      gethomepage.dev/icon: harbor
      gethomepage.dev/name: Harbor
      gethomepage.dev/widget.type: harbor
      gethomepage.dev/widget.url: harbor.prod.techsecom.io
      gethomepage.dev/href: "https://harbor.prod.techsecom.io"
      gethomepage.dev/app: harbor-ingress
      ingress.kubernetes.io/ssl-redirect: "true"
      cert-manager.io/cluster-issuer: letsencrypt-prod
      ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      kubernetes.io/ingress.class: "nginx"
      cert-manager.io/revision-history-limit: "3"
      external-dns.alpha.kubernetes.io/enabled: "true"
      cert-manager.io/duration: "2160h"
      cert-manager.io/renew-before: "720h"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
      # external-dns.alpha.kubernetes.io/target: "rke2-manager.techsecom.io"
      # external-dns.alpha.kubernetes.io/cloudflare-proxied: "true"
    hosts:
      core: harbor.prod.techsecom.io
      notary: notary.prod.techsecom.io
proxy:
  httpProxy:
  httpsProxy:
  noProxy: 127.0.0.1,localhost,.local,.internal
  components:
  - core
  - jobservice
  - trivy

# Use recreate strategy to avoid registry volume stuck in mounting status
updateStrategy:
  type: Recreate

persistence:
  enabled: true
  resourcePolicy: "keep"
  persistentVolumeClaim:
    trivy:
      storageClass: nfs-csi
      size: 10Gi
  imageChartStorage:
    type: "s3"
    # https://github.com/goharbor/harbor-helm/issues/1318
    disableredirect: true
    s3:
      bucket: harbor
      existingSecret: harbor-s3
      regionendpoint: "http://minio.minio.svc.cluster.local:9000"

portal:
  replicas: 3
notary:
  enabled: false

database:
  type: external
  external:
    host: "cnpg-cluster-rw.cnpg-system.svc.cluster.local"
    port: "5432"
    username: "harbor"
    existingSecret: "harbor-user-secret"

redis:
  type: external
  external:
    sentinelMasterSet: "default"
    addr: "redis-cluster-redis-redis.kb-system.svc.cluster.local:6379,redis-cluster-redis-headless.kb-system.svc.cluster.local:6379,redis-cluster-redis-sentinel-headless.kb-system.svc.cluster.local:6379,redis-cluster-redis-sentinel-redis-sentinel.kb-system.svc.cluster.local:6379"
    # https://github.com/goharbor/harbor-helm/issues/1352
    existingSecret: "redis-creds"
    # Copy here the password value from the "redis-creds" secret
    # password: "Techsecoms-@rke2"

metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    # oidc:
    #   enabled: true

    # # Configure components of the External Secrets Operator (ESO).
    # eso:
    #   # -- Install components of the ESO.
    #   enabled: true
    #   # -- Defines provider type. One of `aws` or `generic`.
    #   type: "vault"
    #   # -- Defines Secret Store name.
    #   secretStoreName: "vault"
    #   # -- Value name in AWS ParameterStore, AWS SecretsManager or other Secret Store.
    #   secretName: "secret/harbor"
    #   # -- Role ARN for the ExternalSecretOperator to assume.

    #   gcpsm:
    #     projectID: "alphabet-123"
