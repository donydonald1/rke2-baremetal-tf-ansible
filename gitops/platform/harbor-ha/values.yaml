redis:
  fullnameOverride: redis
  imageRegistry: docker.io
  auth:
    sentinel: false
    existingSecret: redis-creds
    existingSecretPasswordKey: REDIS_PASSWORD
  master:
    persistence:
      size: 1Gi
      storageClass: nfs-csi
  replica:
    persistence:
      size: 1Gi
      storageClass: nfs-csi
    resources:
      requests:
        cpu: 50m
        memory: 100Mi
      limits:
        memory: 512Mi
  sentinel:
    enabled: true

harbor:
  # we use harbor secret to consolidate all the secrets
  existingSecretAdminPassword: harbor
  existingSecretAdminPasswordKey: HARBOR_ADMIN_PASSWORD
  existingSecretSecretKey: harbor

  core:
    replicas: 3
    resources:
      requests:
        cpu: 0.05
        memory: 150Mi
    # xsrfKey: "somekey"
    # (FIXME) This is not yet merged and still not released
    # configureUserSettings: |
    #   {
    #     "auth_mode": "oidc_auth",
    #     "oidc_name": "keycloak",
    #     "oidc_endpoint": "https://keycloak.techsecom.io/auth/realms/shared",
    #     "oidc_client_id": "harbor",
    #     "oidc_client_secret": "YOURSECRET",
    #     "oidc_groups_claim": "roles",
    #     "oidc_admin_group": "administrator",
    #     "oidc_scope": "openid,email,profile,roles",
    #     "oidc_auto_onboard": "true",
    #     "oidc_user_claim": "preferred_username"
    #   }

  jobservice:
    replicas: 3
    secret: ""
    jobLoggers:
    - database
    resources:
      requests:
        cpu: 0.5
        memory: 300Mi

  registry:
    replicas: 3
    secret: ""
    credentials:
      # username is defined in existingSecret below, but this value also used by jobservice, so let's align it
      username: harbor_registry_user
      # we use harbor secret to consolidate all the secrets
      # Secret keys must be REGISTRY_PASSWD and REGISTRY_HTPASSWD. For key REGISTRY_PASSWD the value is the password.
      # For key REGISTRY_HTPASSWD the value is the string in the password file generated by htpasswd where the username
      # is harbor_registry_user and the encryption type is bcrypt.
      # For example: `htpasswd -bBc passwordfile harbor_registry_user harbor_registry_password`. The username must be harbor_registry_user!
      existingSecret: harbor
    registry:
      resources:
        requests:
          cpu: 0.5
          memory: 300Mi
  trivy:
    # enabled the flag to enable Trivy scanner
    enabled: true
    gitHubToken: ""
  fullnameOverride: harbor
  externalURL: https://harbor.prod.techsecom.io
  ipFamily:
    # ipv6Enabled set to true if ipv6 is enabled in cluster, currently it affected the nginx related component
    ipv6:
      enabled: false
  expose:
    tls:
      # we are behind a load balancer, so we don't need to use TLS
      enabled: true
      certSource: secret
      #   secretName: harbor-tls
      secret:
        # The name of secret which contains keys named:
        # "tls.crt" - the certificate
        # "tls.key" - the private key
        secretName: harbor-tls
      # the certificate is used to serve the Harbor UI, API, and registry
    ingress:
      className: nginx
      annotations:
        gethomepage.dev/enabled: "true"
        gethomepage.dev/group: Home
        gethomepage.dev/icon: harbor
        gethomepage.dev/name: Harbor
        gethomepage.dev/widget.type: harbor
        gethomepage.dev/widget.url: harbor.prod.techsecom.io
        gethomepage.dev/href: "https://harbor.prod.techsecom.io"
        gethomepage.dev/app: harbor-ingress
        ingress.kubernetes.io/ssl-redirect: "true"
        cert-manager.io/cluster-issuer: letsencrypt-prod
        ingress.kubernetes.io/proxy-body-size: "0"
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/proxy-body-size: "0"
        # external-dns.alpha.kubernetes.io/target: "rke2-manager.techsecom.io"
        # external-dns.alpha.kubernetes.io/cloudflare-proxied: "true"
      hosts:
        core: harbor.prod.techsecom.io
        notary: notary.prod.techsecom.io
  proxy:
    httpProxy:
    httpsProxy:
    noProxy: 127.0.0.1,localhost,.local,.internal
    components:
    - core
    - jobservice
    - trivy

  # Use recreate strategy to avoid registry volume stuck in mounting status
  updateStrategy:
    type: Recreate

  persistence:
    enabled: true
    resourcePolicy: "keep"
    persistentVolumeClaim:
      trivy:
        storageClass: "vsphere"
        size: 10Gi
    imageChartStorage:
      type: "s3"
      # https://github.com/goharbor/harbor-helm/issues/1318
      disableredirect: true
      s3:
        bucket: harbor
        existingSecret: harbor-s3
        regionendpoint: "http://minio.minio.svc.cluster.local:9000"

  portal:
    replicas: 3
  notary:
    enabled: false

  database:
    type: external
    external:
      host: "hcnpg-cluster-rw.cnpg-system.svc.cluster.local"
      port: "5432"
      username: "harbor"
      existingSecret: "harbor-user-secret"

  redis:
    type: external
    external:
      sentinelMasterSet: "mymaster"
      addr: "redis-node-0.redis-headless.harbor.svc.cluster.local:26379,redis-node-1.redis-headless.harbor.svc.cluster.local:26379,redis-node-2.redis-headless.harbor.svc.cluster.local:26379"
      # https://github.com/goharbor/harbor-helm/issues/1352
      # existingSecret: "harbor-redis"
      # Copy here the password value from the "redis-creds" secret
      password: "Techsecoms-@rke2"

  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

oidc:
  enabled: false

# Configure components of the External Secrets Operator (ESO).
eso:
  # -- Install components of the ESO.
  enabled: true
  # -- Defines provider type. One of `aws` or `generic`.
  type: "vault"
  # -- Defines Secret Store name.
  secretStoreName: "vault"
  # -- Value name in AWS ParameterStore, AWS SecretsManager or other Secret Store.
  secretName: "secret/harbor"
  # -- Role ARN for the ExternalSecretOperator to assume.

  #  gcpsm:
  #    projectID: "alphabet-123"
